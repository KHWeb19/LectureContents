public class ClassTest {
    public static void main(String[] args) {
        // class를 다루는 교육은 사실 과거에는 아래와 같은 방식으로 진행되었다.
        // 1. 그냥 문법 설명
        // 2. 돌아가는 코드
        // 과거의 구시대적 방식

        // 현재는 소프트웨어가 개발된지 그래도 50년 이상이 흘러 많은 이론들이 정립되었다.
        // 소프트웨어 공학(아키텍처): 설계 방법론 등등 많은 것들이 정립됨
        // 그렇기 때문에 이제 더 이상 과거의 비효율적인 실전에 써먹을 수 없는 방식이 좋지 못하다.

        // 먼저 반드시 정리하고 가야할 부분이 있다.
        // [1] 객체란 무엇일까 ?
        // * 추상적인 무언가
        // * 독립적으로 존재할 수 있는 녀석들
        // * 데이터와 함수의 묶음
        // * 몸으로 비유하자면 위장 등등
        // * 클래스가 틀이고 객체가 틀에서 나온 형태

        // 실제로 객체를 현대 소프트웨어 공학에서는 행동을 정의하는 주체로 다룬다.
        // 행동이란 뭘까요 ?
        // * 움직이고 작동하는 것

        // 최근 유행하는 패턴이 있습니다: DDD
        // 한 10년전엔 TDD(Test Driven Development) 였고
        // 지금에 와서는 DDD(Domain Driven Development)가 되었습니다.
        // Domain(도메인) 이란 무엇일까요 ?

        // 우리가 만들려고 하는 최종 목표가 무엇인가 ?
        // * 웹 ?
        // * 웹 사이트
        // * 서비스

        // 돈 벌려고 <<<---
        // 돈을 벌려면 뭘 만들어야 하나요 ?
        // * 사람들이 많이 쓰는 서비스

        // 사람들이 많이 사용하는 서비스에는 어떤 것이 필요한가 ?
        // * 편의성 - 내 시간을 돈으로 사겠다.
        // * 접근성 - 무지성으로 사용이 가능해야함

        // 사람들이 많이만 쓰면 되는가 ? 개발 전반 시스템에 필요한 것은 무엇일까 ?
        // * 보안 - 중요하긴함
        // * 효율성 - 엔티티 오염도를 낮춰야함 < 소통 중요 >
        
        // 어떤 서비스를 처음 만드는 상황에서 모든 상황의 고려가 가능한가 ?
        // * 불가능
        // 지금 현재 잘 나가는 시스템들도 처음부터 모든 상황을 고려한 것이 아님
        
        // 그렇기 때문에 제일 중요한건 변화에 빠른 적응을 하는 것임
        // 변화에 빠르게 적응하려면 >>>>>>>> 엔티티(클래스) <<<<<<<< 를 오염시키면 안됨
        // * 다른 사람이 만든 코드를 함께 재활용하며 써야함
        // * 내가 뭔가를 잘못 건드리면 파생되어 모두 함께 뻥뻥 터짐
        // * 그렇다고 손놓고 가만히 있으면 문제 있는 사람으로 찍힘(승진 및 좌천, 인사고과 등등, 시말서)
        
        // 결국 우리가 문제를 풀 때부터 지속적으로 이야기 했던
        // 분리된 생각을 적용한 클래스를 만들어야함
        // SRP 원칙이라고 하는데
        // 하나의 클래스는 하나의 도메인만 다룬다하여 실제 특정 행동만 다루도록 해야함
        
        // 예) 쿠팽을 만든다고 가정해본다.
        //     이중 주문 시스템을 만든다고 해보자!
        //     [1] 현재 우리가 만들었던 방식
            //     현재 통 메인으로 되어 있기 때문에 기능의 재활용이 어려움
            //     반복되는 루틴이 사라지고 코드가 깔끔해지지 못함
        
        //     [2] 기존 클래스 설계 방식
            //     한 클래스 여러 비즈니스 문제를 처리하고 있음
            //     위의 주문 시스템을 만든다고 하면 어떻게 만들것인가 ?
            //     Order라는 클래스 하나 만들고 여기다 온갖것을 다 때려박을 것이 분명하다.
            //     이것이 바로 엔티티 오염이다.

        // * 결제를 한다고 하면 어떤 것들이 필요한가요 ?
        //   1. 계산(물품에 대한)
        //   2. 물품 정보 (가격 정보)
        //   3. 사용자 정보( 카드, 주소 )

        // * 회원 관리 시스템 (회원 id, pw, 비회원 판정, 배송지 정보 등등)
        // * 물품 관리 시스템 (물품 정보[재고, 가격 등등])
        // * 결제 시스템 (카드 정보, 승인 등등)

        // 다 때려 박으면 뭐가 문제가 될까 ?
        // 새로운 내용이 추가됨
        // 근대 다른 부서에서 사용하는 사람은 그 내용이 필요 없음
        // 어떻게 해야 하는가 ?
        // 새로운 클래스를 또 새롭게 만들어야 하는가 ?
        // 비슷비슷한 코드는 중복되고 ?

        // Q. 다른 부서는 새로운 내용이 왜 필요 없는가 ?
        // A. 자 우리가 사장님이 되었다고 생각해봅시다.
        //    개발자 인건비 최소 3500 정도 잡고 팀당 4명 정도입니다.
        //    1년 사용비: 3500 x 4: 1억 4천만원
        //    기타 간접비, 보험료도 몇천 나옴, 월세, 관리비 등등
        //    이 와중에 재활용을 할 수 있는 코드를 재활용 하지 못하고
        //    길바닥에 돈을 뿌린다면 어떻게 하시겠습니까 ?

        // 이러한 재활용 불가 사태는 엔티티를 오염 시키면 발생하게 됩니다.
        // SRP 규칙: 하나의 클래스는 하나의 도메인(기능 - 행동)만 담당한다.

        // 이와 같은 문제를 해결하기 위해
        // 현대적인 방식에서는 문법은 동일하게 체결하지만
        // 더욱 중요한 것은 엔티티의 오염도를 막는 작업입니다.
        //     [3] 현대적인 방식
            //     * 오염도를 낮출 수 있는 자동화된 방식은 없습니다.
            //     * 이것은 순전히 개발자의 몫
            //     * 이것을 잘 하면 인정받는 개발자가 됩니다.
            //     * 못하면 좌천됩니다.

        // * 오염도를 낮출 수 있는 방법은
        //   하는 행동들이 여러개면 이 행동들 마다
        //   모두 클래스로 만들어서 분리를 시켜야 한다는 것이다.
        //   그러면 집단으로 코드를 작성하는 상황에서 문제가 터질일이 거의 없어진다.
        //   (그래도 터짐 - 상당히 최소화됨)

        // * 앞으로 요 기능을 구현하면 돈을 더 벌겠다 싶어서 개발자를 더 뽑음
        //   근대 기대한 생산성이 나오질 않음
        //   왜 그럴까 ? 원인이 도대체 뭘까 ?
        //   사람은 오지게 뽑아놨는데 왜 개발이 안될까 ?

        // 이미 오염된 엔티티에서 작업을 하는 것은 지뢰밭을 걷는 것과 같다.
        // 만약 이런 회사에 입사한다면 빠른 탈출을 권장한다.
        // 버그 잡느냐고 새로운 기능을 추가할 시간이 없고
        // 당장 급하니까 땜빵만 하면서
        // 정체를 알 수 없는 혼종을 탄생시키게 된다.
        // 당연히 매일 야근이다 <<<< 이런 회사는 워라벨 따위 없다.

        // 실제 컴퓨터 분야에서 객체(object)라는 용어는
        // 메모리 상에 로드(적재)된 데이터를 의미한다.
        // new를 한 정보들은 모두 객체로 취급한다.
        // 그렇기 때문에 지역 변수도 사실은 스코프가 살아있는 동안은 객체로 취급할 수 있다.

        // [2] 객체지향은 뭘까 ?
        //     지금 이야기한 엔티티의 오염도를 낮추면서
        //     모든 행동들을 각각의 클래스로 분리하는게 현대판 객체지향이다.

        // [3] C언어 같은 절차지향형 언어는 객체지향이 안되나 ?
        //     C로도 함수 포인터와 구조체를 이용해서 구현이 가능하다.
        //     특정 언어 패러다임에 갖혀서 시야를 스스로 좁히면 안된다.

        // [4] 요즘은 함수형 언어란것도 있는데 다 뭘까 ?
        //     우리가 향후 배울 파이썬 같은것이 함수형 언어에 해당되기도 한다.
        //     좀 더 정확하게는 lisp이란 녀석이 해당되는데
        //     병렬처리에 특화된 경향을 가지고 있고
        //     역시 자바나 C도 이런 형식의 운용이 가능하다.
        //     자바에선 람다식으로 나타나며 C는 역시 함수 포인터로 다 된다.

        // Class를 어렵게 생각할 필요없이
        // 이 녀석은 사용자가 커스텀하는 데이터타입이다.
        // 데이터 타입은 뭐였는지 생각해보면 되겠다.

        // int, float, double, BigInteger 등등
        // 각각이 표현할 수 있는 정보에 제한이 있었음
        // 어떤 제한이 있나요 ?
        // 표현 범위에 제한이 있음
        // 나는 int, float, double, BigInteger 등등 여러개를 다 같이 쓰고 싶은데 ?
        // int[], float[], double[], BigInteger[] 이렇게 해놓고 쓰면 되지 않나요 ?
        // 네 가능합니다.
        // 근대 이런 패턴이 매번 반복된다면 매번 적으면 되겠죠 ?
        // 한 번에 묶어서 이러한 정보들을 관리할 수 있다면 ?
        // 극단적으로 이와 같은 목적 때문에 사용한다고 이야기 할 수도 있다.
        
        // 클래스를 객체화 시킬 때는
        // 반드시 new 클래스명() 으로 객체화 한다.
        // [ 문법 규칙이 이러함 ]
        Person person = new Person();

        // 객체 내부에 접근할때 '.' 을 사용합니다.
        person.setName("안녕하세요");
        person.setAge(41);

        // * 일단 우리가 문법을 공부해야 하기 때문에
        //   Setter, Getter를 사용하고 있음
        //   실제로 Setter의 경우엔 엔티티를 오염시키는 행위를 하기 때문에 좋지는 않음
        //   그러나 일단은 사용합시다 <<<---- 향후 왜 쓰면 안되는지는 조금 익숙해진 후 진행

        // 결론: 안좋긴 한데 일단 없으면 코드 구현이 불가하니 사용합니다.
        System.out.printf("이름: %s, 나이: %d\n",
                person.getName(), person.getAge());
    }
}
